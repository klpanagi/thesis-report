\section{Βελτιστοποίηση των εργαλείων λογισμικού στο Jetson TK1}
\label{sec:implementations_jetson}

Στο \autoref{sec:jetson_tk1} είχαμε αναφέρει ότι η πλατφόρμα τρέχει
λειτουργικό \emph{Linux4Tegra} το οποίο είναι ουσιαστικά διανομή Ubuntu 14.04
με εγκατεστημένους τους απαραίτητους drivers για το συγκεκριμένο σύστημα.

%προτού ξεκινήσουμε τις υλοποίησεις χρειάστηκε να εγκαταστήσουμε
%τα περισσότερα εργαλεία κατευθείαν πάνω στο μηχάνημα (build from source), για να αποφύγουμε
%την εγκατάστασή pre-compiled λογισμικού. Ο λόγος, όπως και θα φανεί στο \autoref{chapter:experiments},
%είναι ότι η απόδοση των συγκεκριμένων εργαλείων εξαρτάται τόσο από τις
%βιβλιοθήκες που θα χρησιμοποιηθούν για πράξεις γραμμικής άλγεβρας,
%όσο και από τις βελτιστοποιήσεις που γίνονται από τον μεταγλωττιστή κατά την
%διάρκεια της μεταγλώττισης του εκάστοτε πηγαίου κώδικά.

Ένα από τα πρώτα βήματα ήταν να απ-εγκαταστήσουμε από το λειτουργικό το
γραφικό περιβάλλον, για να "κλέψουμε" μνήμη αφού η χωρητικότητα μνήμης
του ενσωματωμένου συστήματος Jetson TK1 είναι περιορισμένη στα 2 Gigabyte,
η οποία είναι κοινή μεταξύ των μονάδων GPU και CPU (shared memory).
Το γραφικό περιβάλλον Gnome
που έρχεται εγκατεστημένο στην διανομή Linux4Tegra μετρήθηκε στα 114 Megabytes.
Το Jetson TK1 συνδέθηκε
μέσω θύρας ethernet στο δίκτυο ενός σταθερού υπολογιστή και έτσι ο χειρισμός
του έγινε μέσω καναλιού ssh\footnote{SSH: Secure Shell \href{https://tools.ietf.org/html/rfc4254}{{https://tools.ietf.org/html/rfc4254}}},
κερδίζοντας έτσι 114 Megabytes σε μνήμη. Αυτό το κέρδος, όπως θα φανεί
αργότερα έπεξε σημαντικό ρόλο καθώς τα νευρωνικά δίκτυο που υλοποιήθηκαν
απαιτούν αρκετή μνήμη κατά την διάρκεια εκτέλεσής τους (της τάξης των Gigabyte).

Στην συνέχεια εγκαταστήσαμε τις βιβλιοθήκες CUDA και cuDNN για να εκμεταλλευτούμε
την υπολογιστική ισχύ της μονάδας GPU. Ο οδηγός για την εγκατάσταση βρίσκεται
στο %\href{http://elinux.org/Jetson_TK1}{http://elinux.org/Jetson_TK1}.
Επιπλέον έχουν γραφεί scripts σε \emph{Bash} για αυτόματη εγκατάσταση και τα
οποία έχουν ανέβει στο \emph{Github} στον σύνδεσμο %\href{https://github.com/klpanagi/Thesis/tree/master/jetson-tk1/}{https://github.com/klpanagi/Thesis/tree/master/jetson-tk1/}.

Ένα μεγάλο μέρος της συνεισφοράς της παρούσας διπλωματική εργασίας
ήταν να γίνουν βελτιστοποιήσεις σε επίπεδο λογισμικού των εργαλείων που χρησιμοποιήθηκαν
για το συγκεκριμένο μηχάνημα.

Αρχικά, ακολουθήσαμε τις οδηγίες για εγκατάσταση των εργαλείων \emph{numpy, scipy, Theano και Keras},
χρησιμοποιώντας τον επίσημο διαχειριστή πακέτων για Python, \emph{pip}.
Τα πρώτα αποτελέσματα σε χρόνους εκτέλεσης πράξεων γραμμικής άλγεβρας ήταν
απαγορευτικά, μίας τάξης μεγέθους πιο κάτω από αυτό που περιμέναμε.
Τόσο η βιβλιοθήκη Theano, όσο και η numpy, χρησιμοποιούν τρίτες βιβλιοθήκες
για πράξεις γραμμικής άλγεβρας, οι οποίες ονομάζονται BLAS (Basic Linear Algebra Subprograms).

Καταλάβαμε ότι το πρόβλημα ήτανε στους υπολογισμούς πράξεων γραμμικής άλγεβρας,
αφού όλες σχεδόν οι μαθηματικές εκφράσεις που εκτελούνται σε ένα
νευρωνικό δίκτυο είναι πράξεις πινάκων. Μετρήσαμε χρόνους εκτέλεσης
ρουτινών BLAS χρησιμοποιώντας και τις 3 βιβλιοθήκες που είναι διαθέσιμες για
επεξεργαστές ARM οι οποίες είναι οι εξής:
\begin{itemize}
  \item{libblas-dev + liblapack3 + libumfpack5.6.2: Προ-εγκατεστημένες στην διανομή Linux4Tegra}
  \item{ATLAS: Ανοικτού κώδικα}
  \item{OpenBLAS: Ανοικτού κώδικα}
\end{itemize}

Τόσο η βιβλιοθήκη ATLAS, όσο και η OpenBLAS, μεταγλωττίστηκαν κατευθείαν από πηγαίο κώδικα,
λαμβάνοντας έτσι υπόψη τις απαραίτητες βελτιστοποιήσεις κατά την διαδικασία
της μεταγλώττισης. Συγκεκριμένα ορίσαμε στον μεταγλωττιστή να χρησιμοποιήσει την αρχιτεκτονική του
συγκεκριμένου επεξεργαστή (armv7) και τις μονάδες
NEON που διαθέτει, για τον υπολογισμό πράξεων με αριθμούς κινητής
υποδιαστολής \emph{ARM Cortex A15}. Επίσης ορίσαμε να χρησιμοποιούνται
τέσσερα νήματα (threads) κατά την εκτέλεση των ρουτινών BLAS.

Στην συνέχεια μετρήσαμε την απόδοση σε χρόνο εκτέλεσης των εξής ρουτινών BLAS:
\begin{itemize}
  \item{Εσωτερικό γινόμενο δύο διανυσμάτων με 1000 στοιχεία το καθένα}
  \item{Εσωτερικό γινόμενο δύο πινάκων διαστάσεων $1000 \times 1000$}
  \item{Αντιστροφή πίνακα διαστάσεων $1000 \times 1000$}
  \item{Υπολογισμός διακρίνουσας πίνακα διαστάσεων $1000 \times 1000$}
  \item{Υπολογισμός ιδιοτιμών πίνακα διαστάσεων $2000 \times 1000$}
  \item{Υπολογισμός ιδιοδιανυσμάτων πίνακα διαστάσεων $1500 \times 1500$}
\end{itemize}
Τρέξαμε κάθε μία από τις πιο πάνω ρουτίνες σε 1000 επαναλήψεις και πήραμε
την μέση τιμή του χρόνου εκτέλεσης.
Οι καλύτεροι χρόνοι λήφθηκαν χρησιμοποιώντας την βιβλιοθήκη OpenBLAS.
Τα συγκριτικά αποτελέσματα μεταξύ της βιβλιοθήκης OpenBLAS και της προεγκατεστημένης
έχουν ως εξής:
\begin{itemize}
  \item{Εσωτερικό γινόμενο πινάκων: $\times 18$}
  \item{Εσωτερικό γινόμενο διανυσμάτων: καμία διαφορά}
  \item{Αντιστροφή πίνακα: $\times 11.5$}
  \item{Υπολογισμός διακρίνουσας πίνακα: $\times 9.6$}
  \item{Υπολογισμός ιδιοτιμών πίνακα: $\times 8.5$}
  \item{Υπολογισμός ιδιοδιανυσμάτων πίνακα: $\times 3.4$}
\end{itemize}
Αντίστοιχα, χρησιμοποιώντας την βιβλιοθήκη ATLAS πήραμε τα εξής αποτελέσματα:
\begin{itemize}
  \item{Εσωτερικό γινόμενο πινάκων: $\times 16$}
  \item{Εσωτερικό γινόμενο διανυσμάτων: $\times 1.5$}
  \item{Αντιστροφή πίνακα: $\times 10.2$}
  \item{Υπολογισμός διακρίνουσας πίνακα: $\times 7.4$}
  \item{Υπολογισμός ιδιοτιμών πίνακα: $\times 7.8$}
  \item{Υπολογισμός ιδιοδιανυσμάτων πίνακα: $\times 3.4$}
\end{itemize}

Αφού καταλήξαμε στην χρησιμοποίηση της βιβλιοθήκης OpenBLAS, συνεχίσαμε
με την μεταγλώττιση από πηγαίο κώδικα των βιβλιοθηκών numpy, scipy και Theano,
οι οποίες εκτελούν τις πράξεις BLAS, ορίζοντας αυτή την φορά στον μεταγλωττιστή
να χρησιμοποιήσει την συγκεκριμένη βιβλιοθήκη αντί της προ-εγκατεστημένης (link against shared library).

Τέλος, εγκαταστήσαμε στον Jetson TK1 την βιβλιοθήκη \emph{CNMeM}
\footnote{\href{https://github.com/NVIDIA/cnmem}{https://github.com/NVIDIA/cnmem}},
η οποία έχει αναπτυχθεί από την Nvidia και χρησιμοποιείται για την εκ-των-προτέρων
δέσμευση μνήμης σε μονάδες GPU που υποστηρίζουν CUDA.
Όπως θα φανεί στο επόμενο κεφάλαιο, η εκ-των-προτέρων δέσμευση μνήμης
επιταχύνει τον χρόνο εκτέλεσης. Ωστόσο απαιτεί σωστή ρύθμιση για να
αποφευχθούν περιπτώσεις δέσμευσης περισσότερης μνήμης από όση το
πρόγραμμα εκτέλεσης απαιτεί.

Σημαντικό να αναφέρουμε ότι όλες οι προαναφερθέντες διαδικασίες εγκατάστασης των
εργαλείων λογισμικού καθώς και τα πειράματα που εκτελέσθηκαν περιγράφονται πλήρως στον
ιστοχώρο: %
\\

\href{https://github.com/klpanagi/Thesis/tree/master/jetson-tk1}{https://github.com/klpanagi/Thesis/tree/master/jetson-tk1}


